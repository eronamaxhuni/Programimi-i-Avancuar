import os
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional # Optional might be needed depending on strictness
from supabase import create_client, Client
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# --- Supabase Configuration ---
url: str = os.environ.get("SUPABASE_URL")
key: str = os.environ.get("SUPABASE_KEY")

if not url or not key:
    raise Exception("Supabase URL and Key must be set in .env file")

supabase: Client = create_client(url, key)
# ----------------------------

app = FastAPI()

# --- Pydantic Models ---
# Model for creating a product (id is generated by DB)
class ProductCreate(BaseModel):
    name: str
    description: Optional[str] = None # Make description optional if it can be NULL in DB
    price: float

# Model for representing a product retrieved from DB (includes id)
class Product(ProductCreate): # Inherits name, description, price
    id: int
    # You could add created_at here if you want to return it
    # created_at: datetime
# -----------------------

# --- API Endpoints ---

@app.get("/products", response_model=List[Product])
def get_products():
    """Retrieves all products from the Supabase table."""
    response = supabase.table('products').select('*').execute()
    # Check for Supabase API errors (optional but good practice)
    # if response.error:
    #     raise HTTPException(status_code=500, detail=str(response.error))
    return response.data

@app.get("/products/{id}", response_model=Product)
def get_product(id: int):
    """Retrieves a single product by its ID."""
    response = supabase.table('products').select('*').eq('id', id).execute()
    if not response.data:
        raise HTTPException(status_code=404, detail=f"Product with id {id} not found")
    # if response.error:
    #     raise HTTPException(status_code=500, detail=str(response.error))
    return response.data[0]

@app.post("/products", response_model=Product, status_code=201)
def create_product(product: ProductCreate):
    """Creates a new product in the Supabase table."""
    # Convert Pydantic model to dictionary for Supabase client
    product_dict = product.dict()
    response = supabase.table('products').insert(product_dict).execute()

    # if response.error:
    #     raise HTTPException(status_code=500, detail=str(response.error))

    # Check if data was returned (successful insert)
    if not response.data:
         raise HTTPException(status_code=500, detail="Failed to create product, no data returned.")

    return response.data[0]

@app.put("/products/{id}", response_model=Product)
def update_product(id: int, updated_product: ProductCreate):
    """Updates an existing product by its ID."""
    product_dict = updated_product.dict()
    response = supabase.table('products').update(product_dict).eq('id', id).execute()

    # if response.error:
    #     raise HTTPException(status_code=500, detail=str(response.error))

    # Check if the update affected any rows (data will contain the updated row)
    if not response.data:
        raise HTTPException(status_code=404, detail=f"Product with id {id} not found or update failed")

    return response.data[0]

@app.delete("/products/{id}", status_code=204)
def delete_product(id: int):
    """Deletes a product by its ID."""
    response = supabase.table('products').delete().eq('id', id).execute()

    # if response.error:
    #     raise HTTPException(status_code=500, detail=str(response.error))

    # Check if any data was returned (meaning a row was deleted)
    # If response.data is empty, it means no row matched the ID.
    if not response.data:
        raise HTTPException(status_code=404, detail=f"Product with id {id} not found")

    # No content to return on successful delete (status code 204)
    return None

# --- Running the App (for local development) ---
# if __name__ == "__main__":
#     import uvicorn
#     uvicorn.run(app, host="0.0.0.0", port=8000)
# -----------------------------------------------